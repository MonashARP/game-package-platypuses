---
title: "Design Decisions for the Blackjack Package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Design Decisions for the Blackjack Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview

This vignette documents the major design choices made while developing the Blackjack R package, including AI usage, limitations, and alternative implementations considered. This work was completed collaboratively as part of a group project for ETC4500 by Min Ni Hong, Shivesh Palanisamy, and Vaishnavi Amuda, involving code, documentation, testing, and design review.

## Use of AI (LLM) Support

We used ChatGPT throughout development for:

-   Writing skeletons for user-facing functions (e.g. `simulate_blackjack_game`)

-   Generating Roxygen documentation templates

-   Creating unit test examples using `testthat`

-   Clarifying base R and vctrs class behavior

-   Debugging `devtools::check()` output

All code was reviewed, modified, or rewritten by human contributors before integration. AI was used *as a coding assistant*, not for final implementation.

## Limitations

While the core game functionality works as intended, the current version of the package has several limitations:

-   No support for Blackjack betting mechanics (e.g., betting chips, insurance, doubling down, splitting).

-   Player AI is rule-based and not probabilistic or adaptive.

-   Multiplayer mode is not implemented, only one player versus the dealer is supported.

-   Only basic strategy is followed (e.g., hit below 17, stand otherwise).

-   No support for saving game state or custom deck configurations.

-   Limited test coverage for edge cases (e.g., all cards of one suit, consecutive face cards).

-   No GUI or Shiny-based frontend.

Unit tests are included for most user-facing functions, but edge cases (e.g. only face cards) are not fully covered.

These limitations were consciously accepted in order to prioritize core game mechanics and code clarity.

## Alternative Designs Considered

We discussed and considered several alternative approaches:

-   **Object system**: We considered using S4 or R6 classes to model cards and decks. Ultimately, we chose S3 with `vctrs::new_rcrd` for simplicity and better compatibility with the tidyverse.

-   **Card representation**: Rather than use base R structures (e.g., lists or character vectors), we created a custom `card` class using `vctrs`. This allowed better type control and more intuitive printing and formatting.

-   **Game strategy**: A full decision table for optimal Blackjack strategy was considered but excluded due to time and complexity. This could be added later.

-   **Deck generation**: We briefly discussed external configuration files (e.g. JSON-based deck layouts) but chose not to include them to keep the package lightweight.

-   **Exposing internal helpers**: We debated exporting low-level functions like `new_card()` and `score_hand_cpp()`, but kept them internal for encapsulation.

## Function Naming, Argument Design, and Workflow

### Function Names

Function names in this package were chosen to be concise, descriptive, and consistent with R naming conventions and Blackjack terminology. Examples include:

-   `simulate_blackjack_game()` clearly conveys that the function simulates one complete round of Blackjack.

-   `card_suit()` and `card_value()` use the `card_` prefix to indicate they operate on the custom `card` vector.

-   `deal_cards()` and `score_hand()` reflect their purpose directly and avoid ambiguity.

### Argument Design

Arguments were kept intuitive and user-friendly:

-   `card(rank, suit)` follows natural card structure and validates input.

-   Functions accept base types (e.g., character, numeric) where possible to minimize the learning curve.

-   Defaults are used where appropriate to allow partial specification or empty input (e.g., `card()` creates an empty card vector).

### User Workflow

We designed the API with a natural workflow in mind:

1.  **Card creation**: Using `card()` to build a hand or deck.

2.  **Game play**: Functions like `deal_cards()` and `simulate_blackjack_game()` handle turn-taking and rules.

3.  **Evaluation**: Functions like `score_hand()` and `card_value()` extract outcomes.

4.  **Inspection**: Users can print cards, check suits/ranks, or test card properties.

This modularity allows advanced users to build their own gameplay loop, or casual users to run a simulation with one function call.

### Use of Internal Modular Functions

We defined several helpers that are intentionally kept internal:

-   `new_card()` constructs `card` objects without validation and is used internally by `card()`.

-   `score_hand_cpp()` wraps the C++ scoring logic and is not exported to avoid misusage.

This helps maintain encapsulation and ensures users interact only with the stable API surface.

### Use of Non-Standard Evaluation (NSE)

NSE was not used in this package. We chose standard evaluation for simplicity, transparency, and better compatibility with testing and debugging workflows.

## Summary

We aimed to strike a balance between extensibility and simplicity. Our core design decisions were:

-   Use S3 + vctrs to model cards with type safety

-   Leverage C++ for scoring logic where performance matters

-   Keep AI minimal and simulation linear

-   Write unit tests to validate gameplay logic

-   Document AI usage and limitations transparently

This package provides a clean foundation for anyone looking to extend a Blackjack engine in R, whether to add features, connect with Shiny, or explore decision theory in gameplay.
